<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Low Poly Landscape</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script>
// EXTN1019B 2025 - Portfolio Item One

// Low Poly Landscape Generator
// Inspired by the aesthetics of Monument Valley
// Low-poly 3D landscape with 'impossible geometry' idea
let terrain = [];
let trees = [];
let structures = [];
let complexity = 15; 
let rotationY = 0;
let rotationX = 0;
let autoRotate = true;
let showTrees = true;
let showStructures = true;
let isDragging = false;
let dragStartX, dragStartY;
let currentPaletteIndex = 0;
let complexitySlider;
let rotateCheckbox;
let treesCheckbox;
let structuresCheckbox;
let paletteButton;
let regenerateButton;
const palettes = [
  {
    name: "Monument Valley",
    sky: [235, 177, 203],
    ground: [
      [255, 145, 126],
      [232, 139, 153],
      [242, 171, 149],
      [255, 201, 147],
      [213, 132, 157]
    ],
    trees: [
      [122, 161, 178],
      [88, 131, 150]
    ],
    structures: [
      [255, 255, 255],
      [240, 240, 240]
    ]
  },
  {
    name: "Sunset",
    sky: [253, 94, 83],
    ground: [
      [255, 172, 78],
      [238, 100, 100],
      [255, 147, 70],
      [247, 182, 67],
      [242, 129, 107]
    ],
    trees: [
      [33, 33, 33],
      [66, 66, 66]
    ],
    structures: [
      [239, 231, 218],
      [224, 216, 203]
    ]
  },
  {
    name: "Arctic",
    sky: [192, 217, 228],
    ground: [
      [255, 255, 255],
      [224, 243, 255],
      [204, 234, 247],
      [178, 223, 242],
      [157, 217, 238]
    ],
    trees: [
      [109, 166, 192],
      [82, 148, 178]
    ],
    structures: [
      [200, 221, 233],
      [168, 205, 224]
    ]
  }
];
function createControls() {
  const controlPanel = createDiv();
  controlPanel.position(10, 10);
  controlPanel.style('background-color', 'rgba(255, 255, 255, 0.8)');
  controlPanel.style('padding', '15px');
  controlPanel.style('border-radius', '8px');
  controlPanel.style('width', '200px');
  controlPanel.id('control-panel');
  
  const title = createP('Low Poly Landscape');
  title.parent(controlPanel);
  title.style('margin-top', '0');
  title.style('font-weight', 'bold');
  
  createP('Polygon Detail:').parent(controlPanel);
  complexitySlider = createSlider(5, 30, complexity, 1);
  complexitySlider.parent(controlPanel);
  complexitySlider.style('width', '100%');
  complexitySlider.input(function() {
    complexity = complexitySlider.value();
    generateTerrain();
    generateTrees();
    generateStructures();
  });
  
  paletteButton = createButton(palettes[currentPaletteIndex].name);
  paletteButton.parent(controlPanel);
  paletteButton.style('margin-top', '10px');
  paletteButton.style('width', '100%');
  paletteButton.mousePressed(function() {
    currentPaletteIndex = (currentPaletteIndex + 1) % palettes.length;
    paletteButton.html(palettes[currentPaletteIndex].name);
  });
  
  rotateCheckbox = createCheckbox('Auto-rotate', autoRotate);
  rotateCheckbox.parent(controlPanel);
  rotateCheckbox.style('margin-top', '10px');
  rotateCheckbox.changed(function() {
    autoRotate = rotateCheckbox.checked();
  });
  
  treesCheckbox = createCheckbox('Show Trees', showTrees);
  treesCheckbox.parent(controlPanel);
  treesCheckbox.changed(function() {
    showTrees = treesCheckbox.checked();
  });
  
  structuresCheckbox = createCheckbox('Show Structures', showStructures);
  structuresCheckbox.parent(controlPanel);
  structuresCheckbox.changed(function() {
    showStructures = structuresCheckbox.checked();
  });
  
  regenerateButton = createButton('Generate New Landscape');
  regenerateButton.parent(controlPanel);
  regenerateButton.style('margin-top', '15px');
  regenerateButton.style('width', '100%');
  regenerateButton.style('padding', '8px');
  regenerateButton.style('background-color', '#4CAF50');
  regenerateButton.style('color', 'white');
  regenerateButton.style('border', 'none');
  regenerateButton.style('border-radius', '4px');
  regenerateButton.style('cursor', 'pointer');
  regenerateButton.mousePressed(function() {
    generateTerrain();
    generateTrees();
    generateStructures();
  });
  
  const instructions = createP('Drag to rotate manually');
  instructions.parent(controlPanel);
  instructions.style('font-size', '12px');
  instructions.style('margin-top', '15px');
  instructions.style('color', '#555');
}
function preload() {
}
function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  
  createControls();
  
  generateTerrain();
  generateTrees();
  generateStructures();
  
  canvas.mousePressed = function(event) {
    if (mouseX > 230) {
      isDragging = true;
      dragStartX = mouseX;
      dragStartY = mouseY;
    }
  };
  
  canvas.mouseReleased = function() {
    isDragging = false;
  };
}
function draw() {
  const palette = palettes[currentPaletteIndex];
  
  background(palette.sky);
  
  if (isDragging) {
    const dx = mouseX - dragStartX;
    const dy = mouseY - dragStartY;
    rotationY += dx * 0.01;
    rotationX += dy * 0.01;
    dragStartX = mouseX;
    dragStartY = mouseY;
  } else if (autoRotate) {
    rotationY += 0.005;
  }
  
  push();
  translate(0, 50, 0);
  rotateX(PI/4 + rotationX);
  rotateY(rotationY);
  scale(15);
  
  drawTerrain();
  
  if (showTrees) {
    drawTrees();
  }
  
  if (showStructures) {
    drawStructures();
  }
  
  pop();
}
function generateTerrain() {
  terrain = [];
  
  for (let x = 0; x < complexity; x++) {
    for (let z = 0; z < complexity; z++) {
      let px = (x / complexity) * 5;
      let pz = (z / complexity) * 5;
      let height = noise(px, pz) * 5;
      
      if (x > complexity / 2 && z > complexity / 2) {
        height += sin((x / complexity) * PI) * cos((z / complexity) * PI) * 2;
      }
      
      if ((x > complexity / 3 && x < complexity / 2 && 
           z > complexity / 3 && z < complexity / 2) ||
          (x > complexity * 0.6 && x < complexity * 0.8 && 
           z > complexity * 0.6 && z < complexity * 0.8)) {
        height = round(height / 2) * 2; 
      }
      
      terrain.push({
        x: (x - complexity/2) * (40/complexity),
        y: height,
        z: (z - complexity/2) * (40/complexity),
        colorIndex: floor(random(5)) 
      });
    }
  }
}
function drawTerrain() {
  const palette = palettes[currentPaletteIndex];
  noStroke();
  
  for (let x = 0; x < complexity-1; x++) {
    for (let z = 0; z < complexity-1; z++) {
      const i1 = x * complexity + z;
      const i2 = x * complexity + (z + 1);
      const i3 = (x + 1) * complexity + z;
      const i4 = (x + 1) * complexity + (z + 1);
      
      const p1 = terrain[i1];
      const p2 = terrain[i2];
      const p3 = terrain[i3];
      const p4 = terrain[i4];
      
      beginShape(TRIANGLES);
      fill(
        palette.ground[p1.colorIndex][0],
        palette.ground[p1.colorIndex][1],
        palette.ground[p1.colorIndex][2]
      );
      vertex(p1.x, p1.y, p1.z);
      vertex(p2.x, p2.y, p2.z);
      vertex(p3.x, p3.y, p3.z);
      endShape();
      
      beginShape(TRIANGLES);
      fill(
        palette.ground[p2.colorIndex][0],
        palette.ground[p2.colorIndex][1],
        palette.ground[p2.colorIndex][2]
      );
      vertex(p2.x, p2.y, p2.z);
      vertex(p4.x, p4.y, p4.z);
      vertex(p3.x, p3.y, p3.z);
      endShape();
    }
  }
}
function generateTrees() {
  trees = [];
  
  const numTrees = floor(random(complexity / 3, complexity / 2));
  
  for (let i = 0; i < numTrees; i++) {
   const x = floor(random(complexity));
    const z = floor(random(complexity));
    const index = x * complexity + z;
    
    if (index >= terrain.length) continue;
    
    const terrainPoint = terrain[index];
    
    trees.push({
      x: terrainPoint.x,
      y: terrainPoint.y,
      z: terrainPoint.z,
      height: random(1, 3),
      colorIndex: floor(random(2))
    });
  }
}
function drawTrees() {
  const palette = palettes[currentPaletteIndex];
  
  for (const tree of trees) {
    push();
    translate(tree.x, tree.y, tree.z);
    
    fill(120, 80, 40);
    noStroke();
    box(0.3, tree.height / 2, 0.3);
    
    translate(0, -tree.height / 2 - 0.5, 0);
    fill(
      palette.trees[tree.colorIndex][0],
      palette.trees[tree.colorIndex][1],
      palette.trees[tree.colorIndex][2]
    );
    
    beginShape(TRIANGLES);
    
    const baseSize = 1.2;
    const top = 1.5;
    
    vertex(-baseSize/2, 0, -baseSize/2);
    vertex(0, -top, 0);
    vertex(baseSize/2, 0, -baseSize/2);
    
    vertex(baseSize/2, 0, -baseSize/2);
    vertex(0, -top, 0);
    vertex(baseSize/2, 0, baseSize/2);
    
    vertex(baseSize/2, 0, baseSize/2);
    vertex(0, -top, 0);
    vertex(-baseSize/2, 0, baseSize/2);
    
    vertex(-baseSize/2, 0, baseSize/2);
    vertex(0, -top, 0);
    vertex(-baseSize/2, 0, -baseSize/2);
    
    endShape();
    
    pop();
  }
}
function generateStructures() {
  structures = [];
  
  const flatAreas = [];
  
  for (let x = 1; x < complexity - 2; x++) {
    for (let z = 1; z < complexity - 2; z++) {
      const index = x * complexity + z;
      const point = terrain[index];
      
      const neighbors = [
        (x-1) * complexity + (z-1),
        (x-1) * complexity + z,
        (x-1) * complexity + (z+1),
        x * complexity + (z-1),
        x * complexity + (z+1),
        (x+1) * complexity + (z-1),
        (x+1) * complexity + z,
        (x+1) * complexity + (z+1)
      ];
      
      let isFlat = true;
      for (const neighborIndex of neighbors) {
        if (neighborIndex < 0 || neighborIndex >= terrain.length) {
          isFlat = false;
          break;
        }
        
        const neighbor = terrain[neighborIndex];
        if (Math.abs(neighbor.y - point.y) > 0.2) {
          isFlat = false;
          break;
        }
      }
      
      if (isFlat) {
        flatAreas.push({
          x: point.x,
          y: point.y,
          z: point.z
        });
      }
    }
  }
  
  const numStructures = min(3, flatAreas.length);
  
  for (let i = 0; i < numStructures; i++) {
    if (flatAreas.length === 0) break;
    
    const randomIndex = floor(random(flatAreas.length));
    const spot = flatAreas[randomIndex];
    flatAreas.splice(randomIndex, 1);
    
    structures.push({
      x: spot.x,
      y: spot.y,
      z: spot.z,
      width: random(1, 2),
      height: random(2, 4),
      depth: random(1, 2),
      rotation: random(TWO_PI),
      type: floor(random(3)), 
      colorIndex: floor(random(2))
    });
  }
}
function drawStructures() {
  const palette = palettes[currentPaletteIndex];
  
  for (const structure of structures) {
    push();
    translate(structure.x, structure.y, structure.z);
    rotateY(structure.rotation);
    
    fill(
      palette.structures[structure.colorIndex][0],
      palette.structures[structure.colorIndex][1],
      palette.structures[structure.colorIndex][2]
    );
    noStroke();
    
    switch (structure.type) {
      case 0:
        box(structure.width, structure.height, structure.depth);
        break;
        
      case 1: 
        push();
        translate(0, structure.height/4, 0);
        box(structure.width, structure.height/2, structure.width);
        
        translate(0, -structure.height/2, 0);
        
        beginShape(TRIANGLES);
        const baseSize = structure.width;
        const sides = 8;
        
        for (let i = 0; i < sides; i++) {
          const angle1 = (i / sides) * TWO_PI;
          const angle2 = ((i+1) / sides) * TWO_PI;
          
          const x1 = cos(angle1) * baseSize/2;
          const z1 = sin(angle1) * baseSize/2;
          
          const x2 = cos(angle2) * baseSize/2;
          const z2 = sin(angle2) * baseSize/2;
          
          vertex(x1, 0, z1);
          vertex(0, -structure.height/2, 0);
          vertex(x2, 0, z2);
        }
        endShape();
        pop();
        break;
        
      case 2: 
        box(structure.width, structure.height/4, structure.depth);
        
        push();
        translate(-structure.width/2 + structure.width/10, -structure.height/3, 0);
        box(structure.width/5, structure.height/2, structure.depth);
        pop();
        
        push();
        translate(structure.width/2 - structure.width/10, -structure.height/3, 0);
        box(structure.width/5, structure.height/2, structure.depth);
        pop();
        
        push();
        translate(0, -structure.height/3 * 2, 0);
        box(structure.width, structure.height/4, structure.depth);
        pop();
        break;
    }
    
    pop();
  }
}
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
function mousePressed() {
  if (mouseX > 230) {
    isDragging = true;
    dragStartX = mouseX;
    dragStartY = mouseY;
    return false; 
  }
  return true; 
}
function mouseReleased() {
  isDragging = false;
}
  </script>
</body>
</html>
